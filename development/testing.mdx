---
title: 'Testing'
description: 'Testing guide for the n-aible backend'
---

This guide covers testing strategies and patterns used in the n-aible backend, with a focus on the authentication module as a reference implementation.

## Test Structure

The test suite follows the same modular structure as the application:

```
tests/
├── conftest.py              # Shared fixtures
├── common/
│   └── fixtures.py         # Common test utilities
└── modules/
    └── auth/
        └── test_router.py  # Auth endpoint tests
```

## Running Tests

<CodeGroup>
```bash Run all tests
cd backend
uv run pytest tests/ -v
```
```bash Run specific module tests
uv run pytest tests/modules/auth/ -v
```
```bash Run specific test file
uv run pytest tests/modules/auth/test_router.py -v
```
```bash Run specific test function
uv run pytest tests/modules/auth/test_router.py::test_register_user_success -v
```
```bash Run with coverage
uv run pytest tests/ --cov=modules --cov-report=html
```
```bash Run with coverage report
uv run pytest tests/ --cov=modules --cov-report=term-missing
```
</CodeGroup>

<Info>
Make sure you've run `uv sync` first to install pytest and test dependencies.
</Info>

## Test Configuration

The test configuration is defined in `pyproject.toml`:

```toml
[tool.pytest.ini_options]
pythonpath = ["."]
testpaths = ["tests"]
```

## Test Fixtures

### Database Session Fixture

The `conftest.py` file provides a database session fixture that creates a fresh SQLite test database for each test:

```python
@pytest.fixture(scope="function")
def db_session():
    """Create a fresh database session for each test."""
    Base.metadata.create_all(bind=engine)
    db = TestSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)
```

### Test Client Fixture

The test client fixture overrides the database dependency to use the test database and supports cookies:

```python
@pytest.fixture(scope="function")
def client(db_session):
    """Create a test client with database override and cookie support."""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass

    app.dependency_overrides[get_db] = override_get_db
    # TestClient with follow_redirects=False to preserve cookies
    yield TestClient(app, follow_redirects=False)
    app.dependency_overrides.clear()
```

<Info>
Each test gets a clean database state, ensuring tests don't interfere with each other. The test client automatically handles HttpOnly cookies for authentication testing.
</Info>

## Authentication Module Tests

The authentication module includes comprehensive tests covering all endpoints and edge cases.

### Register Endpoint Tests

<Tabs>
<Tab title="Success Cases">

```python
def test_register_user_success(client):
    """Test successful user registration."""
    payload = {
        "email": "test@example.com",
        "password": "testpassword123",
        "full_name": "Test User"
    }
    response = client.post("/api/auth/register", json=payload)
    
    assert response.status_code == status.HTTP_201_CREATED
    data = response.json()
    assert data["email"] == payload["email"]
    assert data["full_name"] == payload["full_name"]
    assert data["is_active"] is True
    assert data["role"] == "student"  # Default role
    assert data["is_verified"] is False
    assert "id" in data
    assert "user_id" in data  # Role-based ID
    assert "username" in data
    assert "created_at" in data
    assert "updated_at" in data
    # Check that authentication cookie is set
    assert "access_token" in response.cookies
```

</Tab>

<Tab title="Validation Tests">

```python
def test_register_user_duplicate_email(client):
    """Test registration with duplicate email fails."""
    payload = {
        "email": "duplicate@example.com",
        "password": "testpassword123",
        "full_name": "First User"
    }
    # First registration should succeed
    response1 = client.post("/api/auth/register", json=payload)
    assert response1.status_code == status.HTTP_201_CREATED
    
    # Second registration with same email should fail
    response2 = client.post("/api/auth/register", json=payload)
    assert response2.status_code == status.HTTP_400_BAD_REQUEST
    assert "already registered" in response2.json()["detail"].lower()

def test_register_user_duplicate_username(client):
    """Test registration with duplicate username fails."""
    payload1 = {
        "email": "user1@example.com",
        "password": "testpassword123",
        "username": "duplicate_username"
    }
    payload2 = {
        "email": "user2@example.com",
        "password": "testpassword123",
        "username": "duplicate_username"
    }
    # First registration should succeed
    response1 = client.post("/api/auth/register", json=payload1)
    assert response1.status_code == status.HTTP_201_CREATED
    
    # Second registration with same username should fail
    response2 = client.post("/api/auth/register", json=payload2)
    assert response2.status_code == status.HTTP_400_BAD_REQUEST
    assert "username" in response2.json()["detail"].lower()

def test_register_user_short_password(client):
    """Test registration with password too short fails."""
    payload = {
        "email": "shortpass@example.com",
        "password": "short",
        "full_name": "Test User"
    }
    response = client.post("/api/auth/register", json=payload)
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
```

</Tab>
</Tabs>

### Login Endpoint Tests

<Tabs>
<Tab title="Success Cases">

```python
def test_login_success(client):
    """Test successful login sets cookie and returns user data."""
    # First register a user
    register_payload = {
        "email": "login@example.com",
        "password": "testpassword123",
        "full_name": "Login User"
    }
    client.post("/api/auth/register", json=register_payload)
    
    # Then login
    login_payload = {
        "email": "login@example.com",
        "password": "testpassword123"
    }
    response = client.post("/api/auth/login", json=login_payload)
    
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    # Cookie-based auth: access_token is empty, token_type is "cookie"
    assert data["access_token"] == ""
    assert data["token_type"] == "cookie"
    assert "user" in data
    assert data["user"]["email"] == login_payload["email"]
    # Check that authentication cookie is set
    assert "access_token" in response.cookies
```

</Tab>

<Tab title="Error Cases">

```python
def test_login_wrong_password(client):
    """Test login with wrong password fails."""
    # First register a user
    register_payload = {
        "email": "wrongpass@example.com",
        "password": "correctpassword123",
        "full_name": "Test User"
    }
    client.post("/api/auth/register", json=register_payload)
    
    # Try to login with wrong password
    login_payload = {
        "email": "wrongpass@example.com",
        "password": "wrongpassword123"
    }
    response = client.post("/api/auth/login", json=login_payload)
    
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "incorrect" in response.json()["detail"].lower()

def test_login_nonexistent_user(client):
    """Test login with non-existent email fails."""
    login_payload = {
        "email": "nonexistent@example.com",
        "password": "somepassword123"
    }
    response = client.post("/api/auth/login", json=login_payload)
    
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "incorrect" in response.json()["detail"].lower()
```

</Tab>
</Tabs>

### Logout Endpoint Tests

```python
def test_logout_success(client):
    """Test logout clears authentication cookie."""
    # First register and login
    register_payload = {
        "email": "logout@example.com",
        "password": "testpassword123"
    }
    client.post("/api/auth/register", json=register_payload)
    
    login_payload = {
        "email": "logout@example.com",
        "password": "testpassword123"
    }
    login_response = client.post("/api/auth/login", json=login_payload)
    assert "access_token" in login_response.cookies
    
    # Logout
    logout_response = client.post("/api/auth/logout")
    assert logout_response.status_code == status.HTTP_200_OK
    assert "message" in logout_response.json()
```

### Get Current User Tests

```python
def test_get_current_user_me(client):
    """Test /me endpoint returns current authenticated user."""
    # Register and login
    register_payload = {
        "email": "me@example.com",
        "password": "testpassword123",
        "full_name": "Me User"
    }
    client.post("/api/auth/register", json=register_payload)
    
    login_payload = {
        "email": "me@example.com",
        "password": "testpassword123"
    }
    client.post("/api/auth/login", json=login_payload)
    
    # Get current user
    response = client.get("/api/auth/me")
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["email"] == "me@example.com"
    assert data["full_name"] == "Me User"
    assert "id" in data
    assert "user_id" in data
    assert "role" in data

def test_get_current_user_me_unauthenticated(client):
    """Test /me endpoint requires authentication."""
    response = client.get("/api/auth/me")
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "not authenticated" in response.json()["detail"].lower()
```

## Complete Test Coverage

The authentication module includes 16 comprehensive tests:

<CardGroup cols={3}>
  <Card title="Register Success">
    Tests successful user registration with all fields and cookie setting
  </Card>
  <Card title="Duplicate Email">
    Ensures duplicate emails are rejected
  </Card>
  <Card title="Duplicate Username">
    Ensures duplicate usernames are rejected
  </Card>
  <Card title="Password Validation">
    Validates minimum password length
  </Card>
  <Card title="Email Validation">
    Validates email format
  </Card>
  <Card title="Optional Fields">
    Tests registration without optional fields
  </Card>
  <Card title="Role Assignment">
    Tests registration with specific roles (student/professor/admin)
  </Card>
  <Card title="Custom Username">
    Tests registration with custom username
  </Card>
  <Card title="Login Success">
    Tests successful authentication with cookie-based auth
  </Card>
  <Card title="Wrong Password">
    Tests authentication failure with wrong password
  </Card>
  <Card title="Nonexistent User">
    Tests authentication failure with non-existent user
  </Card>
  <Card title="Invalid Email Format">
    Tests login validation errors
  </Card>
  <Card title="Logout Success">
    Tests logout clears authentication cookie
  </Card>
  <Card title="Get Current User">
    Tests /me endpoint returns authenticated user
  </Card>
  <Card title="Unauthenticated Access">
    Tests /me endpoint requires authentication
  </Card>
  <Card title="Inactive User">
    Tests login with inactive user fails
  </Card>
</CardGroup>

## Testing Cookie-Based Authentication

The test client automatically handles HttpOnly cookies. When you make a request that sets a cookie (like login or register), the cookie is automatically included in subsequent requests:

```python
def test_authenticated_request(client):
    """Test that cookies are automatically included in requests."""
    # Register (sets cookie)
    register_response = client.post("/api/auth/register", json={
        "email": "test@example.com",
        "password": "testpassword123"
    })
    assert "access_token" in register_response.cookies
    
    # Subsequent request automatically includes cookie
    me_response = client.get("/api/auth/me")
    assert me_response.status_code == status.HTTP_200_OK
    # No need to manually set Authorization header
```

<Info>
The TestClient automatically manages cookies between requests, just like a real browser would.
</Info>

## Test Best Practices

<Steps>
  <Step title="Isolate Tests">
    Each test should be independent and not rely on other tests. Use fixtures to set up clean state.
  </Step>
  <Step title="Test Edge Cases">
    Don't just test the happy path. Include validation errors, duplicate data, and error conditions.
  </Step>
  <Step title="Use Descriptive Names">
    Test function names should clearly describe what they're testing (e.g., `test_register_user_duplicate_email`).
  </Step>
  <Step title="Assert Meaningfully">
    Check both status codes and response data to ensure the endpoint behaves correctly.
  </Step>
  <Step title="Test Cookies">
    For cookie-based auth, verify cookies are set and included in subsequent requests.
  </Step>
  <Step title="Clean Up">
    Use fixtures with proper teardown to ensure tests don't leave behind test data.
  </Step>
</Steps>

## Testing Cookie-Based Authentication

The authentication system uses HttpOnly cookies instead of tokens in response bodies. The test client automatically handles this:

### Cookie Handling in Tests

```python
def test_cookie_authentication_flow(client):
    """Test complete cookie-based authentication flow."""
    # 1. Register - cookie is automatically set
    register_response = client.post("/api/auth/register", json={
        "email": "cookie@example.com",
        "password": "testpassword123"
    })
    assert register_response.status_code == status.HTTP_201_CREATED
    assert "access_token" in register_response.cookies
    
    # 2. Access protected endpoint - cookie is automatically included
    me_response = client.get("/api/auth/me")
    assert me_response.status_code == status.HTTP_200_OK
    
    # 3. Logout - cookie is cleared
    logout_response = client.post("/api/auth/logout")
    assert logout_response.status_code == status.HTTP_200_OK
    
    # 4. Access protected endpoint after logout - should fail
    me_response_after_logout = client.get("/api/auth/me")
    assert me_response_after_logout.status_code == status.HTTP_401_UNAUTHORIZED
```

<Info>
The TestClient automatically manages cookies between requests, simulating browser behavior. No need to manually extract or set tokens.
</Info>

## Running Tests in CI/CD

<CodeGroup>
```yaml GitHub Actions
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install uv
        run: pip install uv
      - name: Install dependencies
        run: cd backend && uv sync
      - name: Run tests
        run: cd backend && uv run pytest tests/ -v
      - name: Generate coverage report
        run: cd backend && uv run pytest tests/ --cov=modules --cov-report=xml
```
```bash Local CI Check
cd backend
uv run pytest tests/ -v --tb=short
```
</CodeGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Add More Tests" icon="plus" href="/development/module-pattern">
    Follow the same pattern to add tests for other modules
  </Card>
  <Card title="Integration Tests" icon="link" href="/development/getting-started">
    Learn about integration testing strategies
  </Card>
</CardGroup>

<Check>
All tests passing? You're ready to add more features!
</Check>

