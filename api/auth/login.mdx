---
title: 'Login'
description: 'Authenticate user and receive authentication cookie'
---

Authenticate a user with their email and password. Sets an HttpOnly authentication cookie that is automatically included in subsequent requests. No manual token management required.

<Endpoint method="post" path="/api/auth/login" />

## Request Body

<ParamField body="email" type="string" required>
The email address of the user account.
</ParamField>

<ParamField body="password" type="string" required>
The password for the user account.
</ParamField>

## Request Example

<RequestExample>
```bash cURL
curl -X POST 'http://localhost:8000/api/auth/login' \
  -H 'Content-Type: application/json' \
  -c cookies.txt \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123"
  }'
```
</RequestExample>

<CodeGroup>
```javascript JavaScript
const response = await fetch('http://localhost:8000/api/auth/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  credentials: 'include',  // Required for cookies
  body: JSON.stringify({
    email: 'user@example.com',
    password: 'securepassword123'
  })
});

const data = await response.json();
// Cookie is automatically set by browser
// No need to manually store tokens
```
```python Python
import requests

session = requests.Session()
response = session.post(
    'http://localhost:8000/api/auth/login',
    json={
        'email': 'user@example.com',
        'password': 'securepassword123'
    }
)

data = response.json()
# Cookie is stored in session.cookies automatically
# Use session for subsequent requests
```
</CodeGroup>

## Response

<ResponseField name="access_token" type="string" required>
Always returns empty string `""`. The actual token is stored in an HttpOnly cookie, not in the response body.
</ResponseField>

<ResponseField name="token_type" type="string" required>
Token type, always returns `"cookie"` to indicate cookie-based authentication.
</ResponseField>

<ResponseField name="user" type="object" required>
Complete user object with all user information.
</ResponseField>

## Success Response

<ResponseExample>
```json 200 OK
{
  "access_token": "",
  "token_type": "cookie",
  "user": {
    "id": 1,
    "user_id": "STUD-A1B2C3D4E5",
    "email": "user@example.com",
    "full_name": "John Doe",
    "username": "johndoe",
    "bio": null,
    "avatar_url": null,
    "role": "student",
    "is_active": true,
    "is_verified": false,
    "created_at": "2024-01-15T10:30:00.000000+00:00",
    "updated_at": "2024-01-15T10:30:00.000000+00:00"
  }
}
```
</ResponseExample>

<Info>
An HttpOnly authentication cookie (`access_token`) is automatically set in the response. This cookie is used for subsequent authenticated requests - no manual token management needed.
</Info>

## Error Responses

<ResponseExample>
```json 401 Unauthorized - Invalid Credentials
{
  "detail": "Incorrect email or password"
}
```
</ResponseExample>

<ResponseExample>
```json 422 Unprocessable Entity - Validation Error
{
  "detail": [
    {
      "loc": ["body", "email"],
      "msg": "value is not a valid email address",
      "type": "value_error.email"
    }
  ]
}
```
</ResponseExample>

## Using Authentication

After login, the authentication cookie is automatically included in subsequent requests. No manual token management needed:

<CodeGroup>
```bash cURL
# Cookie is automatically sent with requests
curl -X GET 'http://localhost:8000/api/auth/me' \
  -b cookies.txt
```
```javascript JavaScript
// Cookie is automatically sent with credentials: 'include'
const response = await fetch('http://localhost:8000/api/auth/me', {
  credentials: 'include'  // Required for cookies
});

const user = await response.json();
```
```python Python
# Use the same session - cookies are automatically included
response = session.get('http://localhost:8000/api/auth/me')
user = response.json()
```
</CodeGroup>

## Security Notes

<Warning>
- Authentication cookies are HttpOnly (not accessible via JavaScript, preventing XSS)
- Cookies are Secure in production (HTTPS only)
- Cookies have SameSite=Lax protection (CSRF protection)
- Tokens expire after 30 minutes (configurable via `access_token_exp_minutes`)
- Use HTTPS in production
</Warning>

<Info>
- Passwords are verified using bcrypt
- Invalid credentials return the same error message to prevent user enumeration
- Tokens are signed with the secret key from configuration
- Cookies are automatically managed by the browser - no client-side token storage needed
- More secure than token-in-response-body approach (XSS protection)
</Info>

